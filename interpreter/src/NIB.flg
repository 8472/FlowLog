blackbox emit;
blackbox BBtimer @ 127.0.0.1 9091;

module NIB:

type packet = {locSw, locPt, dlSrc, dlDst, dlTyp, nwSrc, nwDst, nwProto};
type start_timer = {seconds, id};
type timer_expired = {id};
type startup = {};
type switch_port = {switch, port};

///////////////////////////////////////////////////////////
// Before panicking, make sure that you aren't testing with single,n.
// There's no topology to learn there.
///////////////////////////////////////////////////////////

// PURPOSE: Learn which switches have which ports.

// assumption: ports of a switch don't change
plus switch_has_port(sw_pt : switch_port, sw, pt) :-
  sw_pt.switch = sw, sw_pt.port = pt;

///////////////////////////////////////////////////////////

// PURPOSE: Send announcement packets when switches register, and when the timer returns.

// For now, smuggle the sw/pt source in dl fields
// See below for better way using nonces. But also could do w/ new packet type.
// This won't quite work either: the last switch to connect won't get any packets.
action emit(swpt: switch_port, newpkt : packet) :- 
  newpkt.locSw = swpt.switch, newpkt.locPt = swpt.port,
  newpkt.dlTyp = 0x1001, newpkt.dlSrc = swpt.switch, newpkt.dlDst = swpt.port;

// In NIB, a better way would be: a fresh nonce for EACH PACKET EMITTED, and stored in a table. This means that the packets // need not carry their source directly, but more importantly, hosts couldn't spoof. But this is a challenge! More than what
// was sent before. Because AFTER THE SWPT, in the timer triggered emit, it's the unconstraint in the new packet's location
// that says "all ports get a packet" Including a nonce(X) there only gets called once, even if it's fresh. Need a stronger // effect.

action emit(timer: timer_expired, pkt: packet) :- 
  timer.id = "tNIB",
  switch_has_port(pkt.locSw, pkt.locPt),
  pkt.dlTyp = 0x1001, pkt.dlSrc = pkt.locSw, pkt.dlDst = pkt.locPt;

///////////////////////////////////////////////////////////

// PURPOSE: Trigger the timer.

// UNCOMMENT TO UPDATE TOPOLOGY CONTINUOUSLY
//action BBTimer(timer: timer_expired, st: start_timer) :- 
//  st.seconds = 10, st.id = "tNIB", timer.id = "tNIB";

// could also start from first switch registration, and be shorter.
action BBTimer(start: startup, st: start_timer) :- 
  st.seconds = 10, st.id = "tNIB";  

///////////////////////////////////////////////////////////

// PURPOSE: learn the switch topology.

minus ucST(timer: timer_expired, sw1, pt1, sw2, pt2) :- 
  timer.id = "tNIB", 
  ucST(sw1, pt1, sw2, pt2); // <-- to constrain
plus ucST(p: packet, sw1, pt1, sw2, pt2) :-
  p.dlTyp = 0x1001,
  sw1 = p.dlSrc, pt1 = p.dlDst,
  sw2 = p.locSw, pt2 = p.locPt; 

minus switchTopology(timer: timer_expired, sw1, pt1, sw2, pt2) :-
  timer.id = "tNIB",
  switchTopology(sw1, pt1, sw2, pt2); // <-- to constrain
plus switchTopology(timer: timer_expired, sw1, pt1, sw2, pt2) :-  
  timer.id = "tNIB", ucST(sw1, pt1, sw2, pt2);

///////////////////////////////////////////////////////////
// TODO: "NIB" gets treated as variable in XSB. Kludged with lowercase prefix for now.
///////////////////////////////////////////////////////////

// PURPOSE: what's external? 

// an external port is one from which no test packet was received:
minus externalPort(timer: timer_expired, sw, pt) :- 
  timer.id = "tNIB", 
  externalPort(sw, pt);

plus externalPort(timer: timer_expired, sw, pt) :-  
  timer.id = "tNIB",  
  switch_has_port(sw, pt), // <--- constrain
  not ucST(sw, pt, someothersw, someotherpt); // vital to use ucST here

///////////////////////////////////////////////////////////
// TODO: gee, it's easy to type switchHasPort instead of switch_has_port
// and get VERY CONFUSED. 
///////////////////////////////////////////////////////////

// PURPOSE: what host is connected where?

// If we see a packet from an external port...
plus macConnectedAt(pkt: packet, mac, sw, pt) :- not pkt.dlTyp = 0x1001,
  externalPort(sw, pt), mac = pkt.dlSrc, sw=pkt.locSw, pt=pkt.locPt;

///////////////////////////////////////////////////////////
// TODO: easy to say p.dlTyp by mistake and mess everything up.
// It shouldn't but it does via xsb
///////////////////////////////////////////////////////////


// If new mac on this port
minus macConnectedAt(pkt: packet, mac, sw, pt) :- not pkt.dlTyp = 0x1001,
  mac != pkt.dlSrc, sw=pkt.locSw, pt=pkt.locPt,
  macConnectedAt(mac, sw, pt);

// OR if mac was known to be elsewhere (new port number or new switch)
minus macConnectedAt(pkt: packet, mac, sw, pt) :- not pkt.dlTyp = 0x1001,
  mac = pkt.dlSrc, sw=pkt.locSw, pt != pkt.locPt,
  macConnectedAt(mac, sw, pt);
minus macConnectedAt(pkt: packet, mac, sw, pt) :- not pkt.dlTyp = 0x1001,
  mac = pkt.dlSrc, sw != pkt.locSw, pt = pkt.locPt,
  macConnectedAt(mac, sw, pt);

// TODO: How to TEST mobility? Will mininet allow?

///////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////

// PURPOSE: Notice when links come down and when hosts connect/move

///////////////////////////////////////////////////////////

// MOVE THESE TO ANOTHER MODULE
// PURPOSE: spanning tree

///////////////////////////////////////////////////////////

// PURPOSE: shortest path