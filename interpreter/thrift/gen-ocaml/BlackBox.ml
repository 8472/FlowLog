(*
 Autogenerated by Thrift Compiler (0.8.0)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Flowlog_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class doQuery_args =
object (self)
  val mutable _q : query option = None
  method get_q = _q
  method grab_q = match _q with None->raise (Field_empty "doQuery_args.q") | Some _x59 -> _x59
  method set_q _x59 = _q <- Some _x59
  method unset_q = _q <- None
  method reset_q = _q <- None

  method copy =
      let _new = Oo.copy self in
      if _q <> None then
        _new#set_q self#grab_q#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "doQuery_args";
    (match _q with None -> () | Some _v -> 
      oprot#writeFieldBegin("q",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_doQuery_args (iprot : Protocol.t) =
  let _str62 = new doQuery_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t63,_id64) = iprot#readFieldBegin in
        if _t63 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id64 with 
          | 1 -> (if _t63 = Protocol.T_STRUCT then
              _str62#set_q (read_query iprot)
            else
              iprot#skip _t63)
          | _ -> iprot#skip _t63);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str62

class doQuery_result =
object (self)
  val mutable _success : queryReply option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "doQuery_result.success") | Some _x65 -> _x65
  method set_success _x65 = _success <- Some _x65
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "doQuery_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_doQuery_result (iprot : Protocol.t) =
  let _str68 = new doQuery_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t69,_id70) = iprot#readFieldBegin in
        if _t69 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id70 with 
          | 0 -> (if _t69 = Protocol.T_STRUCT then
              _str68#set_success (read_queryReply iprot)
            else
              iprot#skip _t69)
          | _ -> iprot#skip _t69);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str68

class notifyMe_args =
object (self)
  val mutable _notify : notification option = None
  method get_notify = _notify
  method grab_notify = match _notify with None->raise (Field_empty "notifyMe_args.notify") | Some _x71 -> _x71
  method set_notify _x71 = _notify <- Some _x71
  method unset_notify = _notify <- None
  method reset_notify = _notify <- None

  method copy =
      let _new = Oo.copy self in
      if _notify <> None then
        _new#set_notify self#grab_notify#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "notifyMe_args";
    (match _notify with None -> () | Some _v -> 
      oprot#writeFieldBegin("notify",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_notifyMe_args (iprot : Protocol.t) =
  let _str74 = new notifyMe_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t75,_id76) = iprot#readFieldBegin in
        if _t75 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id76 with 
          | 1 -> (if _t75 = Protocol.T_STRUCT then
              _str74#set_notify (read_notification iprot)
            else
              iprot#skip _t75)
          | _ -> iprot#skip _t75);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str74

class notifyMe_result =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "notifyMe_result";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_notifyMe_result (iprot : Protocol.t) =
  let _str79 = new notifyMe_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t80,_id81) = iprot#readFieldBegin in
        if _t80 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id81 with 
          | _ -> iprot#skip _t80);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str79

class virtual iface =
object (self)
  method virtual doQuery : query option -> queryReply
  method virtual notifyMe : notification option -> unit
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method doQuery q = 
    self#send_doQuery q;
    self#recv_doQuery
  method private send_doQuery q = 
    oprot#writeMessageBegin ("doQuery", Protocol.CALL, seqid);
    let args = new doQuery_args in
      args#set_q q;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_doQuery  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_doQuery_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "doQuery failed: unknown result")))
  method notifyMe notify = 
    self#send_notifyMe notify;
    self#recv_notifyMe
  method private send_notifyMe notify = 
    oprot#writeMessageBegin ("notifyMe", Protocol.CALL, seqid);
    let args = new notifyMe_args in
      args#set_notify notify;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_notifyMe  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let _ = read_notifyMe_result iprot in
        iprot#readMessageEnd;
        ()
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 2
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_doQuery (seqid, iprot, oprot) =
    let args = read_doQuery_args iprot in
      iprot#readMessageEnd;
      let result = new doQuery_result in
        result#set_success (handler#doQuery args#get_q);
        oprot#writeMessageBegin ("doQuery", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_notifyMe (seqid, iprot, oprot) =
    let args = read_notifyMe_args iprot in
      iprot#readMessageEnd;
      let result = new notifyMe_result in
        (handler#notifyMe args#get_notify);
        oprot#writeMessageBegin ("notifyMe", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "doQuery" self#process_doQuery;
    Hashtbl.add processMap "notifyMe" self#process_notifyMe;
end

