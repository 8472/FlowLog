
TABLE learned(int, int, int); 
TABLE switch_has_port(int, int); 

// all the events used here are built-in

//blackbox forward;

//module Mac_Learning:

//type packet = {locSw, locPt, dlSrc, dlDst, dlTyp, nwSrc, nwDst, nwProto};
//type switch_port = {switch, port};

ON packet_in(pkt):
	
  // ***TODO*** Add these restrictions (which only exist for limiting to-controller traffic) 
  // automatically. But not always easy! Naive learned/notlearned have some issues
  // in that to use them one sometimes needs complex joins?

  // Instead, bespoke optimizations that can be tested via change impact. (old, unoptimized ==
  // new, optimized?)

  INSERT (pkt.locSw, pkt.locPt, pkt.dlSrc) INTO learned WHERE 
    not learned(pkt.locSw, pkt.locPt, pkt.dlSrc);  

  DELETE (pkt.locSw, pt, pkt.dlSrc) FROM learned WHERE
  	not pt = pkt.locPt 
    // The optimization requirement: ctrlr will learn something new
    AND not learned(pkt.locSw, pkt.locPt, pkt.dlSrc);  

    // This rule doesn't have the negations all at the end of the 
    // resulting clauses. If no pkts forwarded, it means negation-shuffling has failed.
  DO forward(new) WHERE 
    learned(pkt.locSw, new.locPt, pkt.dlDst)
    OR
    (NOT learned(pkt.locSw, any, pkt.dlDst) AND
     NOT pkt.locPt = new.locPt AND
     switch_has_port(pkt.locSw, new.locPt));

     // for testing
//  DO forward(new) WHERE
  	//pkt.locSw = 1 AND
  	//pkt.dlSrc = 1 AND new.locPt != pkt.locPt;

ON switch_port_in(swpt):
	INSERT (swpt.sw, swpt.pt) INTO switch_has_port;

// TODO: still need to use sep var names. we don't have a gensym "_" wildcard
ON switch_down(swd):
  DELETE (swd.sw, any) FROM switch_has_port;
  DELETE (swd.sw, any1, any2) FROM learned;

  
//plus learned(pkt : packet, sw, pt, mac) :-
//pkt.locSw = sw,
//pkt.dlSrc = mac,
//pkt.locPt = pt;

//minus learned(pkt : packet, sw, pt, mac) :-
//pkt.locSw = sw,
//pkt.dlSrc = mac,
// This is to positively constrain the pt variable
//learned(sw, pt, mac),
// Negations MUST GO LAST!
// This is ridiculous but XSB may return no results otherwise.
// TODO:why?
//not pkt.locPt = pt;

//action forward(pkt : packet, nwpkt : packet) :-
//learned(pkt.locSw, nwpkt.locPt, pkt.dlDst);

//plus switch_has_port(sw_pt : switch_port, sw, pt) :-
//sw_pt.switch = sw,
//sw_pt.port = pt;

// omg different var name! but it's ok!
//action forward(pkt : packet, newpkt : packet) :-
//switch_has_port(pkt.locSw, newpkt.locPt),
//not learned(pkt.locSw, any, pkt.dlDst),
//not pkt.locPt = newpkt.locPt;