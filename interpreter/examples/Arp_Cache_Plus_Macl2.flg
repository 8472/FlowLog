/*
ON packet_in(pkt) WHERE pkt.dlTyp = 0x0806 AND pkt.arp_op = 2:

EVENT ALIAS arp_request AS packet_in WHERE pkt.dlTyp = 0x0806 AND pkt.arp_op = 2

ON arp_request(pkt):
  .a...
*/

/* TODO: Implement with soft state. Requires timeouts and enables updates. */

TABLE cached(ipaddr, macaddr);
// request ip, src mac, src ip, src switch, src port
//                      [last 3 should live in NIB; join with NIB]
TABLE queued(ipaddr, macaddr, ipaddr, switchid, portid);
TABLE switch_has_port(switchid, portid);

/*******************************************************************************
 *
 * HANDLE ALL REQUESTS
 *
 ******************************************************************************/

/* TODO: dlTyp must be explicit here for compilation; but should be implied */
ON arp_packet_in(request) WHERE request.arp_op = 1 AND request.dlTyp = 0x0806:

  //
  // If we have a hardware addr cached for the target protocol addr,
  // then emit reply:
  //

  DO emit_arp(new) WHERE
    cached(request.arp_tpa, new.arp_sha) and

    // Make it an ARP reply
    new.arp_op = 2 and
    new.dlTyp = 0x806 and // TODO: see if we can eliminate this as well...

    // Constrain other ARP fields based on request
    new.arp_spa = request.arp_tpa and
    new.arp_tha = request.arp_sha and
    new.arp_tpa = request.arp_spa and

    // Constrain ethernet header appropriately
    new.dlDst = request.dlSrc and
    new.dlSrc = request.arp_tha and

    // Finally, turn packet around (set exit port as entrance)
    new.locSw = request.locSw and
    new.locPt = request.locPt;

  //
  // If request is NOT cached and is NOT from us (the controller),
  // then add it to the table of requests queued their reply
  //

  INSERT (request.arp_tpa, request.arp_sha, request.arp_spa,
          request.locSw, request.locPt) INTO queued WHERE
    not cached(request.arp_tpa, ANY) and
    request.dlSrc != 3405695742; // TODO: can't be from controller 0xCAFECAFE


  //
  // Finally, propagate (flood) an arp request from the controller for unlearned
  // addresses without an existing queued request.
  //

  DO emit_arp(new) WHERE
    not cached(request.arp_tpa, ANY) and
    not queued(request.arp_tpa, ANY, ANY, ANY, ANY) and
    new.dlDst = request.dlDst and
    new.dlSrc = 3405695742 and // TODO: CONTROLER MAC ADDRESS (0xCAFECAFE)

    // Make it an ARP request
    new.arp_op = 1 and

    // Constrain other ARP fields based on request
    new.arp_tpa = request.arp_tpa and
    new.arp_sha = 3405695742 and // TODO: CONTROLER MAC ADDRESS (0xCAFECAFE)
    new.arp_spa = 167772161 and // TODO: CONTROLLER IP ADDR (10.0.0.1)

    // TODO: see if we can eliminate these...
    new.dlTyp = 0x806 and
    switch_has_port(new.locSw, new.locPt); // REQUIRED: this rule is not compiled;

  //
  // Bonus: We can cache the source of this ARP request
  //

  INSERT (request.arp_spa, request.arp_sha) INTO cached WHERE
    not cached(request.arp_spa, ANY);


/*******************************************************************************
 *
 * HANDLE ALL REPLIES
 *
 ******************************************************************************/

/* TODO: dlTyp must be explicit here for compilation; but should be implied */
ON arp_packet_in(reply) WHERE reply.arp_op = 2 AND reply.dlTyp = 0x0806:

  //
  // Learn from replies
  // (No support for changing IP address here: once learned, always learned)
  //

  INSERT (reply.arp_spa, reply.arp_sha) INTO cached WHERE
    not cached(reply.arp_spa, ANY);

  //
  // Clear requests queued for this reply
  //

  DELETE (reply.arp_spa, ANY, ANY, ANY, ANY) FROM queued;

  //
  // Send replies for any queued requests
  //

  DO emit_arp(new) WHERE
    // Make it an ARP reply
    new.arp_op = 2 and
    new.dlTyp = 0x806 and // TODO: see if we can eliminate this as well...

    // Constrain ARP-protocol fields based on queued request
    queued(reply.arp_spa, new.arp_tha, new.arp_tpa, new.locSw, new.locPt) and

    // Constrain remaining fields
    new.dlDst = new.arp_tha and
    new.dlSrc = reply.dlSrc and
    new.arp_spa = reply.arp_spa and
    new.arp_sha = reply.arp_sha;


/*******************************************************************************
 *
 * Populate switch_has_port
 *
 ******************************************************************************/

ON switch_port_in(swpt):
  INSERT (swpt.sw, swpt.pt) INTO switch_has_port;

ON switch_down(swd):
  DELETE (swd.sw, ANY) FROM switch_has_port;
