/*
 * A simple ARP proxy with cache.
 *
 * All ARP requests are sent to the controller (except those issued by the
 * controller, of course). The controller attempts to reply to them from its
 * cache. If the mapping is not found in the cache, then the controller issues
 * its own ARP request to answer the original. We don't want to issue more
 * than one ARP request to any given host, thus we keep a queue of outstanding
 * requests which we are actively proxying.
 *
 * TODO:
 *  - Implement with soft state. Requires timeouts and enables updates.
 *  - Replace controller MAC and IP addresses & arp_op with constants
 *    (requires FlowLog improvements).
 */

/*******************************************************************************
 *
 * Data Structures
 *
 ******************************************************************************/

// Cache for issuing ARP replies. Maps IP to MAC address.
TABLE cached(ipaddr, macaddr);

// Table of queued ARP requests for which we are awaiting a reply from the target
//
// Column values:
// request ip, src mac, src ip, src switch, src port
//                      [last 3 should live in NIB; join with NIB]
TABLE queued(ipaddr, macaddr, ipaddr, switchid, portid);

/*******************************************************************************
 *
 * Only flood ARP requests from the controller
 *
 ******************************************************************************/

ON arp_packet_in(request) WHERE request.dlSrc = 0xCAFECAFE: // Controller MAC
   DO forward(new) WHERE
     new.locPt != request.locPt;

/*******************************************************************************
 *
 * Intercept and process all ARP requests not from the controller
 *
 ******************************************************************************/

ON arp_packet_in(request) WHERE request.arp_op = 1 AND
                                request.dlSrc != 0xCAFECAFE: // Controller MAC

  //
  // If we have a hardware addr cached for the target protocol addr,
  // or it is a self-request, then emit reply:
  //

  DO emit_arp(new) WHERE
    (cached(request.arp_tpa, new.arp_sha) OR
     (request.arp_tpa = request.arp_spa and
      new.arp_sha = request.arp_sha and
      not cached(request.arp_tpa, ANY)) // don't dup packets when also cached
    ) and

    // Make it an ARP reply
    new.arp_op = 2 and

    // Constrain other ARP fields based on request
    new.arp_spa = request.arp_tpa and
    new.arp_tha = request.arp_sha and
    new.arp_tpa = request.arp_spa and

    // Constrain ethernet header appropriately
    new.dlDst = request.dlSrc and
    new.dlSrc = new.arp_sha and

    // Finally, turn packet around (set exit port as entrance)
    new.locSw = request.locSw and
    new.locPt = request.locPt;

  //
  // If request is NOT cached and is NOT from us (the controller),
  // then add it to the table of requests queued their reply
  //

  INSERT (request.arp_tpa, request.arp_sha, request.arp_spa,
          request.locSw, request.locPt) INTO queued WHERE
    not cached(request.arp_tpa, ANY);

    // Infoz on any:
    /// cached(request.arp_tpa, x) ---> exists x | cached ...
    ///not cached(request.arp_tpa, x) ---> exists x | not cached ...
    ///not cached(request.arp_tpa, ANY) ---> not exists x | cached ...     forall x not cached ...

/*

sig EVarp_packet extends EVpacket
  { arp_op: FLInt, arp_tha: Macaddr, arp_sha: Macaddr,
     arp_tpa: Ipaddr, arp_spa: Ipaddr}

assert cachedImmediateReply {
  all st1, st2: State, ev: EVarp_packet |
     (transition[st1, ev, st2] &&
//      some ev2: EVarp_packet | outpolicy[st1, ev, ev2] &&
      ev.arp_op = C_1 &&
      // exists ip | st1.cached[ev.arp_tpa, ip]
      some (st1.cached)[ev.arp_tpa]) implies

      // The only change to state is the requestor's data
      st1 = st2 || st2.cached - st1.cached = (ev.arp_spa -> ev.arp_sha)
     // TODO: add condition about what gets output
}
check cachedImmediateReply for 2 but 1 Event, 2 State
*/


  //
  // Finally, issue an arp request from the controller for unlearned
  // addresses without an existing queued request. The new request is
  // issued from the same switch that started the process.
  //

  DO emit_arp(new) WHERE
    not cached(request.arp_tpa, ANY) and
    not queued(request.arp_tpa, ANY, ANY, ANY, ANY) and
    not request.arp_tpa = request.arp_spa and // skip self-requests
    new.locSw = request.locSw and
    new.dlDst = request.dlDst and
    new.dlSrc = 0xCAFECAFE and

    // Make it an ARP request
    new.arp_op = 1 and

    // Constrain other ARP fields based on original request
    new.arp_tpa = request.arp_tpa and
    new.arp_sha = 0xCAFECAFE and // Controller MAC
    new.arp_spa = 0x0A0A0A01 and // Controller IP addr (10.10.10.1)

    switch_has_port(new.locSw, new.locPt); // REQUIRED: this rule is not compiled

  //
  // Bonus: We can cache the source of this ARP request
  //

  INSERT (request.arp_spa, request.arp_sha) INTO cached WHERE
    not cached(request.arp_spa, ANY);

/*******************************************************************************
 *
 * Handle all ARP replies
 *
 * - Must explicitly specify that no replies will be from the controller;
 *   otherwise, NetCore will try to send copy all controller-issued ARP
 *   traffic back to the controller.
 *
 ******************************************************************************/

ON arp_packet_in(reply) WHERE reply.arp_op = 2 AND
                              reply.dlSrc != 0xCAFECAFE:

  //
  // Learn from replies
  // (No support for changing IP address here: once learned, always learned)
  //

  INSERT (reply.arp_spa, reply.arp_sha) INTO cached WHERE
    not cached(reply.arp_spa, ANY);

  //
  // Clear requests queued for this reply
  //

  DELETE (reply.arp_spa, ANY, ANY, ANY, ANY) FROM queued;

  //
  // Send replies for any queued requests
  //

  DO emit_arp(new) WHERE
    // Make it an ARP reply
    new.arp_op = 2 and

    // Constrain ARP-protocol fields based on queued request
    queued(reply.arp_spa, new.arp_tha, new.arp_tpa, new.locSw, new.locPt) and

    // Constrain remaining fields
    new.dlDst = new.arp_tha and
    new.dlSrc = reply.dlSrc and
    new.arp_spa = reply.arp_spa and
    new.arp_sha = reply.arp_sha;


/*******************************************************************************
 *
 * Primitive contents of "Mac_Learning.inc.flg"
 *
 * Copy-and-pasted from examples/Mac_Learning.flg
 *
 ******************************************************************************/

TABLE learned(switchid, portid, macaddr);

/*
 * TODO: how should we create the syntax to indicate that MAC learning should
 * not be handle packets handled elsewhere? at the same time, it is the
 * forwarding module, so we may want it to handle traffic which doesn't enter
 * via packet_in anyway. Note that we *do* want to learn from the ARP traffic...
 *
 * TODO: Positioning of "pkt.dlTyp != 0x0806" is an open question -- Can we
 * achieve both of these goals?
 *   1) learn from packets which come through the system
 *   2) not affect forwarding of ARP traffic in any way? (including via the
 *      INSERT rule)
 * When positioned on the initial `ON packet_in(pkt)`, we get smaller flow
 * tables from NetCore (helping compensate for NetCore issue #142), but we don't
 * learn anything from ARP traffic. A wholly different approach would be for the
 * ARP handlers above to explicitly add to the learned relation, but I don't
 * like that mixing as it violates modularity...
 *
 */

ON packet_in(pkt) WHERE pkt.dlTyp != 0x0806:
  // ***TODO*** Add these restrictions (which only exist for limiting to-controller traffic)
  // automatically. But not always easy! Naive learned/notlearned have some issues
  // in that to use them one sometimes needs complex joins?

  // Instead, bespoke optimizations that can be tested via change impact. (old, unoptimized ==
  // new, optimized?)

  INSERT (pkt.locSw, pkt.locPt, pkt.dlSrc) INTO learned WHERE
    not learned(pkt.locSw, pkt.locPt, pkt.dlSrc);

  DELETE (pkt.locSw, pt, pkt.dlSrc) FROM learned WHERE
    not pt = pkt.locPt
    // The optimization requirement: ctrlr will learn something new
    AND not learned(pkt.locSw, pkt.locPt, pkt.dlSrc);

    // This rule doesn't have the negations all at the end of the
    // resulting clauses. If no pkts forwarded, it means negation-shuffling has failed.
  DO forward(new) WHERE
    (learned(pkt.locSw, new.locPt, pkt.dlDst) AND
      // NOTE: this line wasn't required in fully reactive version.
      // But now, we may have learned (sw=x,pt=y,mac=z) and see a packet for z
      // on port y (because the switch on that end hasn't yet learned where z is.)
      // This is missing from the stock Mac Learning Frenetic functionality, and
      // lacking it can result in dupe packets when pinging  at topo=tree,3,3
      pkt.locPt != new.locPt
     )
    OR
    (NOT learned(pkt.locSw, x, pkt.dlDst) AND
     NOT pkt.locPt = new.locPt
     // Commented out as **optimization**, only sound if compiled.
     // (If interpreted in XSB, will get a problem because new.locPt isn't bound)
     // AND switch_has_port(pkt.locSw, new.locPt)
    );


ON switch_down(swd):
  DELETE (swd.sw, ANY, ANY) FROM learned;


/*******************************************************************************
 *
 * Primitive contents of "NIB.inc.flg"
 *
 * Populate switch_has_port
 *
 ******************************************************************************/

// Table from switch to ports.
TABLE switch_has_port(switchid, portid);

ON switch_port_in(swpt):
  INSERT (swpt.sw, swpt.pt) INTO switch_has_port;

ON switch_down(swd):
  DELETE (swd.sw, ANY) FROM switch_has_port;
