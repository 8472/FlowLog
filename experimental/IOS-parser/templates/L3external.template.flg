/*
 * Basic functionality for handling external (non-directly attached) subnets.
 *
 * The core of this module is a routing table with a list of subnets and their
 * corresponding gateway's IP address.
 *
 *
 * TODO:
 *  - should issue ARP requests for every nexthop (gateway) IP
 *    automatically, rather than requiring they be entered into the cached
 *    relation by hand at startup.
 */

/*******************************************************************************
 *
 * Data Structures
 *
 ******************************************************************************/

// Routing table for non-directly attached subnets
// subnet, mask, next-hop IP
// TABLE routes(ipaddr, int, ipaddr);

// router id, prefix, mask, outport
REMOTE TABLE routes(switchid, ipaddr, int, portid)
  FROM routes AT 127.0.0.1 9999
  TIMEOUT 15 seconds;

/*******************************************************************************
 *
 * L3 routing to non-directly attached subnets
 *
 * TODO(adf): would be great if NAT were not explicitly considered here
 *
 ******************************************************************************/

// packets destined to outside whose source does NOT need NATing
// (NAT is handled by L3router.flg, even for non-local traffic)

// POLICY ROUTING
ON ip_packet(pkt):
  DO forward(new) WHERE
    // not in a local subnet for this router
    NOT (@dst-local-subnet)
    // don't route packets which need NAT'ing (must send them to NAT first: see L3router)
    and NOT @needs-nat-disj

    // next-hop obtained from policy routing
    and @policyroute-route
    and subnets(nexthop_subnet, nexthop_mask, ANY, new.dlSrc, pkt.locSw, new.locPt)
    and nexthop IN nexthop_subnet/nexthop_mask
    and cached(nexthop, new.dlDst); // MAC addr of nexthop IP

// STATIC OR OSPF ROUTING
// (no support for default-policy routing)
ON ip_packet(pkt):
  DO forward(new) WHERE
    // not in a local subnet for this router
    NOT (@dst-local-subnet)
    // don't route packets which need NAT'ing (must send them to NAT first: see L3router)
    and NOT @needs-nat-disj

    and routes(pkt.locSw, pre, mask, new.locPt) AND
    pkt.nwDst IN pre/mask AND
    // special predicate with special compilation "routes" is hard-coded, do not change!
    NOT hasLongerPrefixMatch(pkt.locSw, pkt.nwDst, pre, mask)

    // no policy route available
    and @policyroute-pass

    and subnets(ANY, ANY, ANY, new.dlSrc, pkt.locSw, new.locPt)
    and cached(nexthop, new.dlDst); // MAC addr of nexthop IP


/*******************************************************************************
 *
 * Per-subnet translators: outbound path to nexthop MAC addr where destination
 * MAC address is already set.
 *
 * TN note: the _inbound_ path for TR switches is handled in L3router.flg
 * This isn't just passthrough: we need to make sure the packet has been hit by the above rule.
 *
 ******************************************************************************/

// TODO(tn) what happens to this block?

ON ip_packet(pkt):
  DO forward(new) WHERE

    // not in a local subnet for this router
    // (prevent overlap with L3router.flg)
    NOT (@dst-local-subnet)

// TODO(tn): test this. seems that we may not need all this extra stuff.
//  not a local subnet, on translator headed toward host; we have the out-port already
// so get the in-port from the portmap

    //and subnets(nexthop_subnet, nexthop_mask, ANY, gwmac, router, rport)
    //and router_tr(router, pkt.locSw)
    //and nexthop IN nexthop_subnet/nexthop_mask
    //and cached(nexthop, pkt.dlDst)
    //and pkt.dlSrc = gwmac
    //and pkt.nwDst != nexthop // this case is handled by internal routing
    and router_portmap(rport, new.locPt, pkt.locPt); // router -> host
